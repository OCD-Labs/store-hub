// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const createTransaction = `-- name: CreateTransaction :one
SELECT id, order_ids, customer_id, amount, payment_provider, provider_tx_ref_id, provider_tx_access_code, provider_tx_fee, status, created_at FROM initialize_transaction(
  $1::bigint,
  $2::NUMERIC(18, 2),
  $3::varchar,
  $4::varchar,
  $5::varchar
)
`

type CreateTransactionParams struct {
	CustomerID           int64  `json:"customer_id"`
	Amount               string `json:"amount"`
	PaymentProvider      string `json:"payment_provider"`
	ProviderTxRefID      string `json:"provider_tx_ref_id"`
	ProviderTxAccessCode string `json:"provider_tx_access_code"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.CustomerID,
		arg.Amount,
		arg.PaymentProvider,
		arg.ProviderTxRefID,
		arg.ProviderTxAccessCode,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		pq.Array(&i.OrderIds),
		&i.CustomerID,
		&i.Amount,
		&i.PaymentProvider,
		&i.ProviderTxRefID,
		&i.ProviderTxAccessCode,
		&i.ProviderTxFee,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingFunds = `-- name: GetPendingFunds :one
SELECT id, store_id, account_type, amount, updated_at, created_at FROM pending_transaction_funds
WHERE store_id = $1
AND account_type = $2
`

type GetPendingFundsParams struct {
	StoreID     int64  `json:"store_id"`
	AccountType string `json:"account_type"`
}

func (q *Queries) GetPendingFunds(ctx context.Context, arg GetPendingFundsParams) (PendingTransactionFund, error) {
	row := q.db.QueryRowContext(ctx, getPendingFunds, arg.StoreID, arg.AccountType)
	var i PendingTransactionFund
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.AccountType,
		&i.Amount,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionByRefID = `-- name: GetTransactionByRefID :one
SELECT id, order_ids, customer_id, amount, payment_provider, provider_tx_ref_id, provider_tx_access_code, provider_tx_fee, status, created_at FROM transactions 
WHERE provider_tx_ref_id = $1
`

func (q *Queries) GetTransactionByRefID(ctx context.Context, providerTxRefID string) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByRefID, providerTxRefID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		pq.Array(&i.OrderIds),
		&i.CustomerID,
		&i.Amount,
		&i.PaymentProvider,
		&i.ProviderTxRefID,
		&i.ProviderTxAccessCode,
		&i.ProviderTxFee,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionOrders = `-- name: GetTransactionOrders :many
SELECT 
  o.id, o.delivery_status, o.delivered_on, o.expected_delivery_date, o.item_id, o.item_price, o.item_currency, o.order_quantity, o.buyer_id, o.seller_id, o.store_id, o.delivery_fee, o.payment_channel, o.payment_method, o.is_reviewed, o.created_at,
  i.name as item_name,
  i.description as item_description,
  s.name as store_name,
  u.account_id as buyer_account_id
FROM transactions t
JOIN unnest(t.order_ids) AS order_id ON true
JOIN orders o ON o.id = order_id
JOIN items i ON i.id = o.item_id
JOIN stores s ON s.id = o.store_id
JOIN users u ON u.id = o.buyer_id
WHERE t.provider_tx_ref_id = $1
`

type GetTransactionOrdersRow struct {
	ID                   int64     `json:"id"`
	DeliveryStatus       string    `json:"delivery_status"`
	DeliveredOn          time.Time `json:"delivered_on"`
	ExpectedDeliveryDate time.Time `json:"expected_delivery_date"`
	ItemID               int64     `json:"item_id"`
	ItemPrice            string    `json:"item_price"`
	ItemCurrency         string    `json:"item_currency"`
	OrderQuantity        int32     `json:"order_quantity"`
	BuyerID              int64     `json:"buyer_id"`
	SellerID             int64     `json:"seller_id"`
	StoreID              int64     `json:"store_id"`
	DeliveryFee          string    `json:"delivery_fee"`
	PaymentChannel       string    `json:"payment_channel"`
	PaymentMethod        string    `json:"payment_method"`
	IsReviewed           bool      `json:"is_reviewed"`
	CreatedAt            time.Time `json:"created_at"`
	ItemName             string    `json:"item_name"`
	ItemDescription      string    `json:"item_description"`
	StoreName            string    `json:"store_name"`
	BuyerAccountID       string    `json:"buyer_account_id"`
}

func (q *Queries) GetTransactionOrders(ctx context.Context, providerTxRefID string) ([]GetTransactionOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionOrders, providerTxRefID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionOrdersRow{}
	for rows.Next() {
		var i GetTransactionOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.DeliveryStatus,
			&i.DeliveredOn,
			&i.ExpectedDeliveryDate,
			&i.ItemID,
			&i.ItemPrice,
			&i.ItemCurrency,
			&i.OrderQuantity,
			&i.BuyerID,
			&i.SellerID,
			&i.StoreID,
			&i.DeliveryFee,
			&i.PaymentChannel,
			&i.PaymentMethod,
			&i.IsReviewed,
			&i.CreatedAt,
			&i.ItemName,
			&i.ItemDescription,
			&i.StoreName,
			&i.BuyerAccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStorePendingFunds = `-- name: ListStorePendingFunds :many
SELECT 
  ptf.id, ptf.store_id, ptf.account_type, ptf.amount, ptf.updated_at, ptf.created_at,
  s.name as store_name
FROM pending_transaction_funds ptf
JOIN stores s ON s.id = ptf.store_id
WHERE 
  CASE 
    WHEN $1::bigint IS NOT NULL THEN ptf.store_id = $1
    ELSE true
  END
ORDER BY ptf.amount DESC
LIMIT $3
OFFSET $2
`

type ListStorePendingFundsParams struct {
	StoreID  sql.NullInt64 `json:"store_id"`
	RwOffset int32         `json:"rw_offset"`
	RwLimit  int32         `json:"rw_limit"`
}

type ListStorePendingFundsRow struct {
	ID          int64     `json:"id"`
	StoreID     int64     `json:"store_id"`
	AccountType string    `json:"account_type"`
	Amount      string    `json:"amount"`
	UpdatedAt   time.Time `json:"updated_at"`
	CreatedAt   time.Time `json:"created_at"`
	StoreName   string    `json:"store_name"`
}

func (q *Queries) ListStorePendingFunds(ctx context.Context, arg ListStorePendingFundsParams) ([]ListStorePendingFundsRow, error) {
	rows, err := q.db.QueryContext(ctx, listStorePendingFunds, arg.StoreID, arg.RwOffset, arg.RwLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStorePendingFundsRow{}
	for rows.Next() {
		var i ListStorePendingFundsRow
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.AccountType,
			&i.Amount,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.StoreName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const processTransaction = `-- name: ProcessTransaction :one
SELECT id, order_ids, customer_id, amount, payment_provider, provider_tx_ref_id, provider_tx_access_code, provider_tx_fee, status, created_at FROM process_transaction_completion(
  $1::varchar,
  $2::varchar,
  $3::NUMERIC(10, 2),
  $4::jsonb
)
`

type ProcessTransactionParams struct {
	ProviderTxRefID string          `json:"provider_tx_ref_id"`
	Status          string          `json:"status"`
	ProviderTxFee   string          `json:"provider_tx_fee"`
	CartItems       json.RawMessage `json:"cart_items"`
}

func (q *Queries) ProcessTransaction(ctx context.Context, arg ProcessTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, processTransaction,
		arg.ProviderTxRefID,
		arg.Status,
		arg.ProviderTxFee,
		arg.CartItems,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		pq.Array(&i.OrderIds),
		&i.CustomerID,
		&i.Amount,
		&i.PaymentProvider,
		&i.ProviderTxRefID,
		&i.ProviderTxAccessCode,
		&i.ProviderTxFee,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const releaseFunds = `-- name: ReleaseFunds :exec
SELECT release_pending_funds($1::bigint)
`

func (q *Queries) ReleaseFunds(ctx context.Context, orderID int64) error {
	_, err := q.db.ExecContext(ctx, releaseFunds, orderID)
	return err
}
